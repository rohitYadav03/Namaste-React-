ğŸ“Œ Class-Based Components in React

1ï¸âƒ£ Creating a Class Component
A class component is a JavaScript class that extends React.Component.
It must have a render() method that returns JSX.

Example:
class UserClass extends React.Component {
    render() {
        return <h2>Hello, I am a class component!</h2>;
    }
}
Important: Every class component must extend React.Component to inherit React features.

2ï¸âƒ£ Props in Class Components
Props are passed from the parent and can be accessed using this.props.
Example of using props in a class component:

class UserClass extends React.Component {
    render() {
        return <h2>Name: {this.props.name}</h2>;
    }
}
// Using the component
root.render(<UserClass name="Rohit Yadav" />);

3ï¸âƒ£ Constructor in Class Components
The constructor is optional but is used when:
We initialize state.
We modify or use props inside the constructor.
When using a constructor, we must call super(props).
Example:

class UserClass extends React.Component {
    constructor(props) {
        super(props);  // Calls the parent constructor (React.Component)
        console.log(this.props);  // âœ… Now this.props is available
    }

    render() {
        return <h2>Name: {this.props.name}</h2>;
    }
}
If we donâ€™t use super(props), this.props will be undefined!

4ï¸âƒ£ Understanding super(props)
super() calls the parent class (React.Component) constructor.
super(props) ensures that this.props is available inside the constructor.
If you donâ€™t call super(props), React will throw an error when accessing this.props inside the constructor.

Code	            Effect
super()	            Calls the parent constructor but doesnâ€™t initialize this.props.
super(props)	    Calls the parent constructor and initializes this.props.
No super()	âŒ      this is not initialized â†’ Error when accessing this.props.

5ï¸âƒ£ When to Use a Constructor?
âœ… Use a constructor only if:
You need to initialize state.
You need to modify or use props inside the constructor.
âŒ If the component only uses props and doesnâ€™t need state, do not write a constructor.

âœ… Without a constructor (best practice if no state is needed):

class UserClass extends React.Component {
    render() {
        return <h2>Name: {this.props.name}</h2>;
    }
}

6ï¸âƒ£ Summary of Class Components
Extend React.Component	Required to make a class a React component.
render() method	Must return JSX.
Props (this.props)	Used to pass data from parent to child component.
Constructor (constructor)	Used when we need state or to modify props.
super(props)	Calls the parent constructor and initializes this.props.

ğŸ”¥ Key Takeaways
Class components must extend React.Component.
Props are accessed using this.props.
Constructor is only needed if using state or modifying props.
Always call super(props) inside the constructor if using props.
If thereâ€™s no state, avoid using a constructor to keep the code clean

7ï¸âƒ£ State in Class Components
State is an object that holds component-specific data.
Use this.state to define the initial state inside the constructor.
Use this.setState() to update the state and trigger re-render.

âš¡ Key Points:
this.state stores the componentâ€™s data.
this.setState() updates the state and re-renders the component.
Never modify state directly (this.state.count++ âŒ), always use this.setState() âœ….

8ï¸âƒ£ Component Lifecycle Methods
React provides lifecycle methods to control component behavior at different phases.

âœ… Lifecycle Order:
Constructor â†’ Render â†’ componentDidMount
Re-render when state or props change
componentWillUnmount before component removal

componentDidMount() â€“ Best for API Calls
Runs only once after the component loads to UI (ideal for API calls).
âš¡ Key Points:
Used for API calls, event listeners, or subscriptions.
Ensures the UI renders first before making an API request.

ğŸ”Ÿ React Re-Rendering & State Updates
State updates cause re-renders.
React batches updates for performance.
If parent props change, child re-renders automatically.

1ï¸âƒ£1ï¸âƒ£ componentDidUpdate() â€“ Runs on State/Props Change
Executes after every update (re-render) if props or state change.

âœ… Example:
componentDidUpdate(prevProps, prevState) {
    if (prevState.count !== this.state.count) {
        console.log("Count updated:", this.state.count);
    }
}
âš¡ Key Points:
Used to run side effects after updates (e.g., logging, fetching new data).
Compare prevProps or prevState to avoid unnecessary API calls.

1ï¸âƒ£2ï¸âƒ£ componentWillUnmount() â€“ Cleanup Before Component Removal
Runs before a component is removed from the DOM.

âœ… Example:
componentWillUnmount() {
    console.log("Component is being removed!");
}

âš¡ Key Points:
Used to remove event listeners, clear intervals, or clean up resources.

ğŸ”¥ Final Takeaways on Class Components
âœ” Use this.state for managing component-specific data.
âœ” Update state using this.setState(), never modify state directly.
âœ” Lifecycle methods (componentDidMount, componentDidUpdate, componentWillUnmount) help manage side effects.
âœ” API calls should be made inside componentDidMount() to prevent UI blocking.
âœ” Use componentWillUnmount() for cleanup tasks like clearing timers or event listeners.

ğŸ”¥ Summary of React Lifecycle Flow
1. Parent Constructor
2. Parent Render
3. Child Constructor
4. Child Render
5. React Updates DOM
6. Child componentDidMount
7. Parent componentDidMount
8. If State Changes -> Render Again -> componentDidUpdate
9. If Component Removed -> componentWillUnmount

âœ… React renders parent first, then children.
âœ… React mounts children before calling componentDidMount() in parent.
âœ… If parent updates, children may re-render but wonâ€™t re-mount.
âœ… Unmounting removes child components first.

âœ… Re-render: Only render() runs. State & lifecycle methods (componentDidMount) remain unchanged.
âœ… Re-mount: Component is destroyed and recreated. constructor and componentDidMount run again, and state resets.

âœ… Mounting â†’ Runs constructor(), creates UI with render(), then componentDidMount() (best for API calls).
âœ… Updating â†’ When state/props change, render() runs again, and componentDidUpdate() is triggered.
âœ… Unmounting â†’ Before removing a component, componentWillUnmount() runs to clean up side effects.